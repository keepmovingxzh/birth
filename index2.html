<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿æ§åˆ¶æ˜Ÿäº‘å›¾</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #ff8a00, #e52e71);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            width: 100%;
            max-width: 1400px;
        }
        
        .camera-section {
            flex: 1;
            min-width: 400px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .nebula-section {
            flex: 1.5;
            min-width: 500px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .section-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #7e8ce0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .section-title i {
            font-size: 1.3rem;
        }
        
        .video-container {
            position: relative;
            width: 100%;
            height: 300px;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            border-radius: 10px;
        }
        
        .control-title {
            font-size: 1.1rem;
            margin-bottom: 10px;
            color: #a8b1ff;
        }
        
        .gesture-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .gesture-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            transition: all 0.3s;
        }
        
        .gesture-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .gesture-icon {
            width: 40px;
            height: 40px;
            background: rgba(126, 140, 224, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }
        
        .gesture-desc {
            flex: 1;
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px 15px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4757;
        }
        
        .status-dot.active {
            background: #2ed573;
        }
        
        #nebula-canvas {
            width: 100%;
            height: 500px;
            display: block;
        }
        
        .nebula-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 1.1rem;
        }
        
        .nebula-name {
            color: #7e8ce0;
            font-weight: bold;
        }
        
        .instructions {
            margin-top: 30px;
            max-width: 800px;
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
        }
        
        .instructions h2 {
            margin-bottom: 15px;
            color: #7e8ce0;
        }
        
        .instructions p {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 30px;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left: 4px solid #7e8ce0;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }
            
            .camera-section, .nebula-section {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>æ‰‹åŠ¿æ§åˆ¶æ˜Ÿäº‘å›¾</h1>
        <p class="subtitle">ä½¿ç”¨æ‘„åƒå¤´è¯†åˆ«æ‰‹åŠ¿æ¥æ§åˆ¶æ˜Ÿäº‘å›¾çš„ç¼©æ”¾å’Œåˆ‡æ¢</p>
    </header>
    
    <div class="container">
        <div class="camera-section">
            <h2 class="section-title">
                <span>ğŸ‘ï¸</span> æ‘„åƒå¤´ä¸æ‰‹åŠ¿è¯†åˆ«
            </h2>
            
            <div class="video-container">
                <video id="video" autoplay playsinline></video>
                <canvas id="canvas"></canvas>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h3 class="control-title">æ‰‹åŠ¿æ§åˆ¶</h3>
                    <div class="gesture-list">
                        <div class="gesture-item">
                            <div class="gesture-icon">ğŸ‘Š</div>
                            <div class="gesture-desc">æ¡æ‹³å‘å†… - ç¼©å°æ˜Ÿäº‘å›¾</div>
                        </div>
                        <div class="gesture-item">
                            <div class="gesture-icon">ğŸ‘‹</div>
                            <div class="gesture-desc">æ‰‹æŒå‘å¤– - æ”¾å¤§æ˜Ÿäº‘å›¾</div>
                        </div>
                        <div class="gesture-item">
                            <div class="gesture-icon">ğŸ‘ˆ</div>
                            <div class="gesture-desc">å‘å·¦æ»‘åŠ¨ - ä¸Šä¸€ä¸ªæ˜Ÿäº‘</div>
                        </div>
                        <div class="gesture-item">
                            <div class="gesture-icon">ğŸ‘‰</div>
                            <div class="gesture-desc">å‘å³æ»‘åŠ¨ - ä¸‹ä¸€ä¸ªæ˜Ÿäº‘</div>
                        </div>
                    </div>
                </div>
                
                <div class="status">
                    <div class="status-dot" id="status-dot"></div>
                    <span id="status-text">æ­£åœ¨åŠ è½½æ¨¡å‹...</span>
                </div>
            </div>
        </div>
        
        <div class="nebula-section">
            <h2 class="section-title">
                <span>ğŸŒŒ</span> æ˜Ÿäº‘å›¾
            </h2>
            
            <canvas id="nebula-canvas"></canvas>
            
            <div class="nebula-info">
                å½“å‰æ˜Ÿäº‘: <span class="nebula-name" id="nebula-name">èºæ—‹æ˜Ÿäº‘</span>
            </div>
        </div>
    </div>
    
    <div class="instructions">
        <h2>ä½¿ç”¨è¯´æ˜</h2>
        <p>1. å…è®¸æµè§ˆå™¨è®¿é—®æ‚¨çš„æ‘„åƒå¤´</p>
        <p>2. å°†æ‚¨çš„æ‰‹æ”¾åœ¨æ‘„åƒå¤´å‰ï¼Œç¡®ä¿å…‰çº¿å……è¶³</p>
        <p>3. ä½¿ç”¨ä¸Šè¿°æ‰‹åŠ¿æ§åˆ¶æ˜Ÿäº‘å›¾</p>
        <p>4. å¦‚æœæ‰‹åŠ¿è¯†åˆ«ä¸å‡†ç¡®ï¼Œè¯·å°è¯•è°ƒæ•´æ‰‹ä¸æ‘„åƒå¤´çš„è·ç¦»å’Œè§’åº¦</p>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let video;
        let canvas;
        let ctx;
        let nebulaCanvas;
        let nebulaCtx;
        let model;
        let predictions = [];
        let isModelLoaded = false;
        let lastGesture = '';
        let gestureStartTime = 0;
        
        // æ˜Ÿäº‘å›¾ç›¸å…³å˜é‡
        let nebulaScale = 1.0;
        let currentNebula = 0;
        const nebulaNames = ['èºæ—‹æ˜Ÿäº‘', 'çŒæˆ·åº§æ˜Ÿäº‘', 'èŸ¹çŠ¶æ˜Ÿäº‘', 'çŒ«çœ¼æ˜Ÿäº‘', 'åˆ›ç”Ÿä¹‹æŸ±'];
        let particles = [];
        const particleCount = 1000;
        
        // åˆå§‹åŒ–å‡½æ•°
        async function init() {
            // è·å–DOMå…ƒç´ 
            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            nebulaCanvas = document.getElementById('nebula-canvas');
            nebulaCtx = nebulaCanvas.getContext('2d');
            
            // è®¾ç½®Canvaså°ºå¯¸
            setupCanvas();
            window.addEventListener('resize', setupCanvas);
            
            // åˆå§‹åŒ–æ˜Ÿäº‘ç²’å­
            initNebula();
            
            // åŠ è½½æ‰‹åŠ¿è¯†åˆ«æ¨¡å‹
            try {
                updateStatus('æ­£åœ¨åŠ è½½æ‰‹åŠ¿è¯†åˆ«æ¨¡å‹...', false);
                model = await handpose.load();
                updateStatus('æ¨¡å‹åŠ è½½æˆåŠŸ!', true);
                isModelLoaded = true;
                
                // å¯åŠ¨æ‘„åƒå¤´
                await setupCamera();
                
                // å¼€å§‹æ£€æµ‹æ‰‹åŠ¿
                detectHand();
                
                // å¼€å§‹åŠ¨ç”»å¾ªç¯
                animateNebula();
            } catch (error) {
                console.error('åˆå§‹åŒ–é”™è¯¯:', error);
                updateStatus('åˆå§‹åŒ–å¤±è´¥: ' + error.message, false);
            }
        }
        
        // è®¾ç½®Canvaså°ºå¯¸
        function setupCanvas() {
            // è§†é¢‘Canvas
            canvas.width = video.offsetWidth;
            canvas.height = video.offsetHeight;
            
            // æ˜Ÿäº‘Canvas
            nebulaCanvas.width = nebulaCanvas.offsetWidth;
            nebulaCanvas.height = nebulaCanvas.offsetHeight;
        }
        
        // åˆå§‹åŒ–æ˜Ÿäº‘ç²’å­
        function initNebula() {
            particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: Math.random() * nebulaCanvas.width,
                    y: Math.random() * nebulaCanvas.height,
                    size: Math.random() * 3 + 1,
                    speedX: (Math.random() - 0.5) * 0.5,
                    speedY: (Math.random() - 0.5) * 0.5,
                    color: `hsl(${Math.random() * 60 + 200}, 70%, ${Math.random() * 30 + 50}%)`,
                    orbitX: nebulaCanvas.width / 2,
                    orbitY: nebulaCanvas.height / 2,
                    orbitRadius: Math.random() * 150 + 50,
                    orbitSpeed: (Math.random() - 0.5) * 0.02,
                    angle: Math.random() * Math.PI * 2
                });
            }
        }
        
        // è®¾ç½®æ‘„åƒå¤´
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480 } 
                });
                video.srcObject = stream;
                
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        resolve();
                    };
                });
            } catch (error) {
                console.error('æ‘„åƒå¤´è®¿é—®é”™è¯¯:', error);
                updateStatus('æ— æ³•è®¿é—®æ‘„åƒå¤´: ' + error.message, false);
                throw error;
            }
        }
        
        // æ£€æµ‹æ‰‹åŠ¿
        async function detectHand() {
            if (!isModelLoaded) return;
            
            try {
                predictions = await model.estimateHands(video);
                
                // ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹
                drawHand();
                
                // åˆ†ææ‰‹åŠ¿
                analyzeGesture();
                
                // ç»§ç»­æ£€æµ‹
                requestAnimationFrame(detectHand);
            } catch (error) {
                console.error('æ‰‹åŠ¿æ£€æµ‹é”™è¯¯:', error);
                setTimeout(detectHand, 1000);
            }
        }
        
        // ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹
        function drawHand() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (predictions.length > 0) {
                for (let i = 0; i < predictions.length; i++) {
                    const keypoints = predictions[i].landmarks;
                    
                    // ç»˜åˆ¶å…³é”®ç‚¹
                    for (let j = 0; j < keypoints.length; j++) {
                        const [x, y] = keypoints[j];
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 5, 0, 2 * Math.PI);
                        ctx.fillStyle = '#7e8ce0';
                        ctx.fill();
                    }
                    
                    // ç»˜åˆ¶è¿æ¥çº¿
                    drawConnections(keypoints, ctx);
                }
            }
        }
        
        // ç»˜åˆ¶æ‰‹éƒ¨è¿æ¥çº¿
        function drawConnections(keypoints, ctx) {
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4], // æ‹‡æŒ‡
                [0, 5], [5, 6], [6, 7], [7, 8], // é£ŸæŒ‡
                [0, 9], [9, 10], [10, 11], [11, 12], // ä¸­æŒ‡
                [0, 13], [13, 14], [14, 15], [15, 16], // æ— åæŒ‡
                [0, 17], [17, 18], [18, 19], [19, 20], // å°æŒ‡
                [0, 17] // æ‰‹æŒ
            ];
            
            ctx.strokeStyle = '#7e8ce0';
            ctx.lineWidth = 2;
            
            for (let i = 0; i < connections.length; i++) {
                const [start, end] = connections[i];
                const [x1, y1] = keypoints[start];
                const [x2, y2] = keypoints[end];
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        
        // åˆ†ææ‰‹åŠ¿
        function analyzeGesture() {
            if (predictions.length === 0) {
                lastGesture = '';
                return;
            }
            
            const keypoints = predictions[0].landmarks;
            
            // è®¡ç®—æ‰‹éƒ¨ä¸­å¿ƒç‚¹
            const centerX = keypoints.reduce((sum, kp) => sum + kp[0], 0) / keypoints.length;
            const centerY = keypoints.reduce((sum, kp) => sum + kp[1], 0) / keypoints.length;
            
            // è®¡ç®—æ‰‹æŒ‡å°–åˆ°æ‰‹æŒçš„è·ç¦»
            const fingerTips = [4, 8, 12, 16, 20]; // æ‹‡æŒ‡ã€é£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡çš„æŒ‡å°–
            const wrist = keypoints[0]; // æ‰‹è…•
            
            let totalDistance = 0;
            for (let i = 0; i < fingerTips.length; i++) {
                const tip = keypoints[fingerTips[i]];
                const distance = Math.sqrt(
                    Math.pow(tip[0] - wrist[0], 2) + 
                    Math.pow(tip[1] - wrist[1], 2)
                );
                totalDistance += distance;
            }
            const avgDistance = totalDistance / fingerTips.length;
            
            // æ£€æµ‹æ‰‹åŠ¿
            const now = Date.now();
            
            // æ¡æ‹³æ£€æµ‹ (æ‰‹æŒ‡é è¿‘æ‰‹æŒ)
            if (avgDistance < 70) {
                if (lastGesture !== 'fist' && now - gestureStartTime > 500) {
                    lastGesture = 'fist';
                    gestureStartTime = now;
                    zoomNebula(-0.2);
                }
            } 
            // æ‰‹æŒå¼ å¼€æ£€æµ‹
            else if (avgDistance > 100) {
                if (lastGesture !== 'open' && now - gestureStartTime > 500) {
                    lastGesture = 'open';
                    gestureStartTime = now;
                    zoomNebula(0.2);
                }
            }
            // æ»‘åŠ¨æ£€æµ‹
            else {
                // ç®€å•çš„æ‰‹éƒ¨ç§»åŠ¨æ£€æµ‹
                if (lastGesture === '') {
                    lastGesture = 'tracking';
                    gestureStartTime = now;
                } else if (lastGesture === 'tracking' && now - gestureStartTime > 1000) {
                    // æ£€æµ‹æ°´å¹³ç§»åŠ¨
                    const thumbTip = keypoints[4];
                    const pinkyTip = keypoints[20];
                    
                    // å¦‚æœæ‰‹æ˜¯æ¨ªå‘çš„
                    if (Math.abs(thumbTip[1] - pinkyTip[1]) < 50) {
                        if (thumbTip[0] < pinkyTip[0]) {
                            // æ‹‡æŒ‡åœ¨å·¦ï¼Œå°æŒ‡åœ¨å³ - å‘å·¦æ»‘åŠ¨
                            lastGesture = 'swipe_left';
                            gestureStartTime = now;
                            changeNebula(-1);
                        } else {
                            // æ‹‡æŒ‡åœ¨å³ï¼Œå°æŒ‡åœ¨å·¦ - å‘å³æ»‘åŠ¨
                            lastGesture = 'swipe_right';
                            gestureStartTime = now;
                            changeNebula(1);
                        }
                    }
                }
            }
        }
        
        // ç¼©æ”¾æ˜Ÿäº‘å›¾
        function zoomNebula(delta) {
            nebulaScale += delta;
            nebulaScale = Math.max(0.5, Math.min(3, nebulaScale));
            
            // æ›´æ–°æ˜Ÿäº‘ç²’å­å¤§å°
            for (let i = 0; i < particles.length; i++) {
                particles[i].size = Math.random() * 3 * nebulaScale + 1;
            }
        }
        
        // åˆ‡æ¢æ˜Ÿäº‘
        function changeNebula(direction) {
            currentNebula += direction;
            if (currentNebula < 0) currentNebula = nebulaNames.length - 1;
            if (currentNebula >= nebulaNames.length) currentNebula = 0;
            
            document.getElementById('nebula-name').textContent = nebulaNames[currentNebula];
            
            // é‡æ–°åˆå§‹åŒ–æ˜Ÿäº‘ç²’å­
            initNebula();
        }
        
        // åŠ¨ç”»æ˜Ÿäº‘
        function animateNebula() {
            nebulaCtx.fillStyle = 'rgba(10, 10, 30, 0.1)';
            nebulaCtx.fillRect(0, 0, nebulaCanvas.width, nebulaCanvas.height);
            
            // æ›´æ–°å’Œç»˜åˆ¶ç²’å­
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                
                // æ ¹æ®å½“å‰æ˜Ÿäº‘ç±»å‹æ›´æ–°ç²’å­è¡Œä¸º
                switch(currentNebula) {
                    case 0: // èºæ—‹æ˜Ÿäº‘
                        p.angle += p.orbitSpeed;
                        p.x = p.orbitX + Math.cos(p.angle) * p.orbitRadius * nebulaScale;
                        p.y = p.orbitY + Math.sin(p.angle) * p.orbitRadius * nebulaScale;
                        p.orbitRadius += 0.05;
                        break;
                    case 1: // çŒæˆ·åº§æ˜Ÿäº‘
                        p.x += p.speedX;
                        p.y += p.speedY;
                        
                        if (p.x < 0 || p.x > nebulaCanvas.width) p.speedX *= -1;
                        if (p.y < 0 || p.y > nebulaCanvas.height) p.speedY *= -1;
                        break;
                    case 2: // èŸ¹çŠ¶æ˜Ÿäº‘
                        p.angle += p.orbitSpeed;
                        p.x = p.orbitX + Math.cos(p.angle) * p.orbitRadius * nebulaScale;
                        p.y = p.orbitY + Math.sin(p.angle) * p.orbitRadius * nebulaScale;
                        p.orbitRadius -= 0.02;
                        if (p.orbitRadius < 10) p.orbitRadius = 150;
                        break;
                    case 3: // çŒ«çœ¼æ˜Ÿäº‘
                        p.x += p.speedX * nebulaScale;
                        p.y += p.speedY * nebulaScale;
                        
                        if (p.x < 0 || p.x > nebulaCanvas.width) p.speedX *= -1;
                        if (p.y < 0 || p.y > nebulaCanvas.height) p.speedY *= -1;
                        
                        // å‘ä¸­å¿ƒç‚¹ç§»åŠ¨
                        const dx = p.orbitX - p.x;
                        const dy = p.orbitY - p.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        p.x += dx / dist * 0.5;
                        p.y += dy / dist * 0.5;
                        break;
                    case 4: // åˆ›ç”Ÿä¹‹æŸ±
                        p.x += p.speedX;
                        p.y += p.speedY * 2;
                        
                        if (p.y > nebulaCanvas.height) {
                            p.y = 0;
                            p.x = Math.random() * nebulaCanvas.width;
                        }
                        break;
                }
                
                // ç»˜åˆ¶ç²’å­
                nebulaCtx.beginPath();
                nebulaCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                nebulaCtx.fillStyle = p.color;
                nebulaCtx.fill();
            }
            
            requestAnimationFrame(animateNebula);
        }
        
        // æ›´æ–°çŠ¶æ€
        function updateStatus(message, isSuccess) {
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');
            
            statusText.textContent = message;
            
            if (isSuccess) {
                statusDot.classList.add('active');
            } else {
                statusDot.classList.remove('active');
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>