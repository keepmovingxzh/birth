<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>æ‰‹åŠ¿æ§åˆ¶æ˜Ÿäº‘å›¾ (Three.js + MediaPipe)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-container { position: absolute; bottom: 20px; right: 20px; z-index: 2; width: 320px; height: 240px; border-radius: 10px; overflow: hidden; border: 2px solid rgba(255,255,255,0.3); transform: scaleX(-1); /* é•œåƒç¿»è½¬è§†é¢‘ */ }
        video { width: 100%; height: 100%; object-fit: cover; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-family: sans-serif; font-size: 24px; pointer-events: none; z-index: 10; }
        .instruction { position: absolute; top: 20px; left: 20px; color: rgba(255,255,255,0.7); font-family: sans-serif; z-index: 3; pointer-events: none; }
    </style>
    <!-- å¼•å…¥ MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨åŠ è½½æ¨¡å‹å’Œæ‘„åƒå¤´...</div>
    <div class="instruction">
        <h3>æ‰‹åŠ¿æ§åˆ¶æŒ‡å—ï¼š</h3>
        <p>ğŸ‘Œ <b>åŒæŒ‡æåˆ/å¼ å¼€</b>ï¼šæ‹‡æŒ‡ä¸é£ŸæŒ‡è·ç¦»æ§åˆ¶æ˜Ÿäº‘å¤§å°</p>
        <p>ğŸ‘‹ <b>æŒ¥æ‰‹ (å·¦å³æ»‘åŠ¨)</b>ï¼šæ‰‹æŒå‘å·¦/å‘å³å¿«é€Ÿç§»åŠ¨åˆ‡æ¢æ˜Ÿäº‘å½¢çŠ¶</p>
    </div>

    <div id="video-container">
        <video class="input_video"></video>
    </div>
    <div id="canvas-container"></div>

<script>
    // ================= THREE.JS æ˜Ÿäº‘è®¾ç½® =================
    let scene, camera, renderer, particles;
    let currentShapeIndex = 0;
    const shapes = ['galaxy', 'tunnel', 'sphere']; // ä¸‰ç§å½¢çŠ¶
    
    function initThree() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        // æ·»åŠ ä¸€ç‚¹é›¾æ°”å¢åŠ æ·±é‚ƒæ„Ÿ
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        createParticles(shapes[currentShapeIndex]);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animateThree();
    }

    function createParticles(type) {
        if (particles) scene.remove(particles);

        const geometry = new THREE.BufferGeometry();
        const count = 5000;
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);

        const color1 = new THREE.Color(0x00ffff); // é’è‰²
        const color2 = new THREE.Color(0xff00ff); // ç´«è‰²

        for (let i = 0; i < count; i++) {
            let x, y, z;
            
            if (type === 'galaxy') {
                // èºæ—‹æ˜Ÿç³»
                const branchAngle = (i % 3) * ((2 * Math.PI) / 3);
                const radius = Math.random() * 30;
                const spinAngle = radius * 1; 
                
                const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 2;
                const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 2;
                const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 2;

                x = Math.cos(branchAngle + spinAngle) * radius + randomX;
                y = randomY * 2; // æ‰å¹³ä¸€ç‚¹
                z = Math.sin(branchAngle + spinAngle) * radius + randomZ;
            } else if (type === 'tunnel') {
                // æ—¶ç©ºéš§é“
                const angle = Math.random() * Math.PI * 2;
                const radius = 10 + Math.random() * 20;
                const depth = (Math.random() - 0.5) * 100;
                x = Math.cos(angle) * radius;
                y = Math.sin(angle) * radius;
                z = depth;
            } else {
                // æ··ä¹±çƒä½“
                const r = 30 * Math.cbrt(Math.random());
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            }

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            // æ··åˆé¢œè‰²
            const mixedColor = color1.clone().lerp(color2, Math.random());
            colors[i * 3] = mixedColor.r;
            colors[i * 3 + 1] = mixedColor.g;
            colors[i * 3 + 2] = mixedColor.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // åˆ›å»ºå‘å…‰æè´¨
        const material = new THREE.PointsMaterial({
            size: 0.5,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);
    }

    function animateThree() {
        requestAnimationFrame(animateThree);
        
        if (particles) {
            particles.rotation.y += 0.002; // è‡ªåŠ¨ç¼“æ…¢æ—‹è½¬
            
            // å¦‚æœæ˜¯éš§é“æ¨¡å¼ï¼Œå¢åŠ é£è¡Œçš„æ„Ÿè§‰
            if (shapes[currentShapeIndex] === 'tunnel') {
                particles.rotation.z += 0.001;
            }
        }
        renderer.render(scene, camera);
    }

    // ================= MEDIAPIPE æ‰‹åŠ¿è¯†åˆ« =================
    
    const videoElement = document.getElementsByClassName('input_video')[0];
    let lastPalmX = null;
    let swipeCooldown = false;
    const SWIPE_THRESHOLD = 0.15; // æ»‘åŠ¨çµæ•åº¦

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];

            // 1. ç¼©æ”¾æ§åˆ¶ (æ‹‡æŒ‡ Tip: 4, é£ŸæŒ‡ Tip: 8)
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            
            // è®¡ç®—ä¸¤æŒ‡ä¹‹é—´çš„æ¬§å‡ é‡Œå¾—è·ç¦»
            const distance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );

            // æ˜ å°„è·ç¦»åˆ°æ˜Ÿäº‘ç¼©æ”¾ (è·ç¦»é€šå¸¸åœ¨ 0.02 åˆ° 0.3 ä¹‹é—´)
            // æˆ‘ä»¬å¸Œæœ›æ‰‹æŒ‡å¼ å¼€(distå¤§) -> æ”¾å¤§(scaleå¤§)
            // æ‰‹æŒ‡æåˆ(distå°) -> ç¼©å°(scaleå°)
            const scale = Math.max(0.1, Math.min(3.0, distance * 5)); 
            
            // å¹³æ»‘è¿‡æ¸¡
            if (particles) {
                particles.scale.set(scale, scale, scale);
            }

            // 2. åˆ‡æ¢å½¢çŠ¶ (æ‰‹æŒä¸­å¿ƒ: 0 æˆ– 9)
            const palmX = landmarks[9].x; // ä½¿ç”¨ä¸­æŒ‡æ ¹éƒ¨ä½œä¸ºæ‰‹æŒä¸­å¿ƒå‚è€ƒ
            
            if (lastPalmX !== null && !swipeCooldown) {
                const deltaX = palmX - lastPalmX;

                // æ³¨æ„ï¼šMediaPipe xåæ ‡æ˜¯å½’ä¸€åŒ–çš„ [0, 1]ï¼Œä¸”è§†é¢‘é€šå¸¸æ˜¯é•œåƒçš„
                // å‘å·¦æ»‘ (deltaX < è´Ÿé˜ˆå€¼) æˆ– å‘å³æ»‘ (deltaX > æ­£é˜ˆå€¼)
                if (Math.abs(deltaX) > SWIPE_THRESHOLD) {
                    // è§¦å‘åˆ‡æ¢
                    if (deltaX > 0) {
                        // å¾€å³æ»‘ (å®é™…ä¸Šå› ä¸ºé•œåƒæ˜¯å¾€å·¦) -> ä¸Šä¸€ä¸ª
                        currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
                    } else {
                        // å¾€å·¦æ»‘ -> ä¸‹ä¸€ä¸ª
                        currentShapeIndex = (currentShapeIndex - 1 + shapes.length) % shapes.length;
                    }
                    
                    createParticles(shapes[currentShapeIndex]);
                    
                    // å†·å´æ—¶é—´ï¼Œé˜²æ­¢ä¸€æ¬¡æ»‘åŠ¨è§¦å‘å¤šæ¬¡åˆ‡æ¢
                    swipeCooldown = true;
                    setTimeout(() => { swipeCooldown = false; }, 1000);
                }
            }
            lastPalmX = palmX;

        } else {
            // å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°æ‰‹ï¼Œé‡ç½®çŠ¶æ€
            lastPalmX = null;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraMedia = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });

    // å¯åŠ¨ç¨‹åº
    initThree();
    cameraMedia.start();

</script>
</body>
</html>