<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>æ‰‹åŠ¿æ§åˆ¶æ˜Ÿäº‘ - ç»ˆæå¯è§†åŒ–ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Microsoft YaHei', sans-serif; }
        
        /* 3D åœºæ™¯å®¹å™¨ */
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* è§†é¢‘å’Œå¯è§†åŒ–å®¹å™¨ (å³ä¸‹è§’) */
        #camera-wrapper {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            z-index: 100;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(0,0,0,0.5);
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ï¼Œè®©æ“ä½œç¬¦åˆç›´è§‰ */
        }

        /* åŸå§‹è§†é¢‘å…ƒç´  (éšè—ï¼Œåªç”¨ä½œæ•°æ®æº) */
        .input_video { display: none; }

        /* ç»˜åˆ¶éª¨æ¶çš„ Canvas */
        .output_canvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* æç¤ºå’ŒåŠ è½½æ–‡å­— */
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px; pointer-events: none; z-index: 10; text-align: center; }
        .instruction { position: absolute; top: 20px; left: 20px; color: rgba(255,255,255,0.6); z-index: 3; pointer-events: none; text-shadow: 0 0 5px #000; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; }
        .key-hint { font-size: 12px; color: #aaa; margin-top: 5px; }
        
        /* ç‰¹æ•ˆæ–‡å­—å±‚ */
        .overlay-text {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 80px; font-weight: bold;
            color: transparent;
            background-image: linear-gradient(to right, #ff00cc, #3333ff, #00ccff);
            -webkit-background-clip: text; background-clip: text;
            opacity: 0;
            transition: opacity 0.8s ease-in-out, transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 5; pointer-events: none; text-align: center; white-space: nowrap;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }
        .overlay-text.active { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
        
        /* çŠ¶æ€æŒ‡ç¤ºç¯ */
        .status-indicator {
            position: absolute; bottom: 10px; right: 350px; color: white; z-index: 5;
            font-size: 14px; opacity: 0.8;
        }
    </style>
    
    <!-- MediaPipe æ ¸å¿ƒåº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading">ç³»ç»Ÿå¯åŠ¨ä¸­...<br><span style="font-size:16px">è¯·å…è®¸æ‘„åƒå¤´æƒé™</span></div>
    
    <div class="instruction">
        <h3>ğŸ® äº¤äº’æŒ‡å—</h3>
        <p>ğŸŸ¡ <b>æ‹‡æŒ‡+é£ŸæŒ‡</b>ï¼šå¼ å¼€/æåˆæ§åˆ¶ç¼©æ”¾</p>
        <p>ğŸ”´ <b>çº¢ç‚¹ (æ‰‹å¿ƒ)</b>ï¼šå¿«é€Ÿå·¦å³ç§»åŠ¨åˆ‡æ¢åœºæ™¯</p>
        <div class="key-hint">âŒ¨ï¸ ä¹Ÿå¯ä»¥ä½¿ç”¨é”®ç›˜ â† å·¦ / å³ â†’ é”®åˆ‡æ¢</div>
    </div>

    <div class="status-indicator" id="status-text">ç­‰å¾…æ‰‹åŠ¿...</div>

    <div id="text-birthday" class="overlay-text">ğŸ‚ ç”Ÿæ—¥å¿«ä¹ï¼ğŸ‰</div>
    <div id="text-name" class="overlay-text">âœ¨ è§£æ”¿æ·¼ âœ¨</div>

    <!-- æ‘„åƒå¤´ä¸å¯è§†åŒ–åŒºåŸŸ -->
    <div id="camera-wrapper">
        <video class="input_video"></video>
        <canvas class="output_canvas" width="320" height="240"></canvas>
    </div>

    <div id="canvas-container"></div>

<script>
    // ================= THREE.JS åœºæ™¯è®¾ç½® (ä¿æŒé«˜çº§è›‹ç³•ç‰ˆ) =================
    let scene, camera, renderer, particles, cakeGroup;
    let cakeFlames = []; 
    let currentShapeIndex = 0;
    const shapes = ['galaxy', 'cake_mode', 'sphere']; 
    let targetScale = 1.0; 
    
    function initThree() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x111111, 0.002); 

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 40;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);
        const spotLight = new THREE.SpotLight(0xffaa00, 0.5);
        spotLight.position.set(-10, 10, 0);
        scene.add(spotLight);

        createParticles(shapes[0]);
        createCake(); 

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animateThree();
    }

    function createParticles(type) {
        if (particles) scene.remove(particles);
        if (type === 'cake_mode') type = 'tunnel'; 

        const geometry = new THREE.BufferGeometry();
        const count = 6000;
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        const color1 = new THREE.Color(0x00ffff);
        const color2 = new THREE.Color(0xff00ff);

        for (let i = 0; i < count; i++) {
            let x, y, z;
            if (type === 'galaxy') {
                const branchAngle = (i % 5) * ((2 * Math.PI) / 5);
                const radius = Math.random() * 35;
                const spinAngle = radius * 0.8; 
                x = Math.cos(branchAngle + spinAngle) * radius + (Math.random()-0.5)*2;
                y = (Math.random()-0.5) * 4; 
                z = Math.sin(branchAngle + spinAngle) * radius + (Math.random()-0.5)*2;
            } else if (type === 'tunnel') {
                const angle = Math.random() * Math.PI * 2;
                const radius = 15 + Math.random() * 15;
                const depth = (Math.random() - 0.5) * 120;
                x = Math.cos(angle) * radius;
                y = Math.sin(angle) * radius;
                z = depth;
            } else {
                const r = 25 * Math.cbrt(Math.random());
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            }
            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;
            const mixedColor = color1.clone().lerp(color2, Math.random());
            colors[i * 3] = mixedColor.r;
            colors[i * 3 + 1] = mixedColor.g;
            colors[i * 3 + 2] = mixedColor.b;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const material = new THREE.PointsMaterial({
            size: 0.4, vertexColors: true, blending: THREE.AdditiveBlending,
            depthWrite: false, transparent: true, opacity: 0.8
        });
        particles = new THREE.Points(geometry, material);
        scene.add(particles);
    }

    function createCake() {
        cakeGroup = new THREE.Group();
        cakeFlames = []; 
        const creamWhiteMat = new THREE.MeshStandardMaterial({ color: 0xfffff0, roughness: 0.3 }); 
        const creamPinkMat = new THREE.MeshStandardMaterial({ color: 0xffc0cb, roughness: 0.3 });  
        const plateMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.1, metalness: 0.3 }); 
        const cherryMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.1, metalness: 0.1 }); 
        const candleMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.2, metalness: 0.4 }); 
        const flameMat = new THREE.MeshBasicMaterial({ color: 0xff6600 }); 

        const plate = new THREE.Mesh(new THREE.CylinderGeometry(11, 10, 0.5, 64), plateMat);
        plate.position.y = -2; plate.receiveShadow = true; cakeGroup.add(plate);
        
        const baseLayer = new THREE.Mesh(new THREE.CylinderGeometry(9, 9, 4, 64), creamWhiteMat);
        baseLayer.castShadow = true; cakeGroup.add(baseLayer);

        for(let i=0; i<16; i++) {
            const angle = (i / 16) * Math.PI * 2;
            const puff = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), creamPinkMat);
            puff.position.set(Math.cos(angle) * 8.5, -1.8, Math.sin(angle) * 8.5);
            cakeGroup.add(puff);
        }

        const topLayer = new THREE.Mesh(new THREE.CylinderGeometry(6.5, 6.5, 3.5, 64), creamPinkMat);
        topLayer.position.y = 3.75; topLayer.castShadow = true; cakeGroup.add(topLayer);

        const ring = new THREE.Mesh(new THREE.TorusGeometry(6.3, 0.4, 16, 64), creamWhiteMat);
        ring.rotation.x = Math.PI / 2; ring.position.y = 2.0; cakeGroup.add(ring);

        for(let i=0; i<8; i++) {
            const cherry = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), cherryMat);
            cherry.position.set(Math.cos((i/8)*Math.PI*2)*5.8, 5.6, Math.sin((i/8)*Math.PI*2)*5.8);
            cakeGroup.add(cherry);
        }

        for(let i=0; i<5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            const candle = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 2.5, 16), candleMat);
            candle.position.set(Math.cos(angle)*3.5, 6.5, Math.sin(angle)*3.5);
            cakeGroup.add(candle);
            const flame = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.8, 16), flameMat);
            flame.position.set(0, 1.6, 0); candle.add(flame); cakeFlames.push(flame);
            const candleLight = new THREE.PointLight(0xffaa00, 0.5, 5);
            candleLight.position.set(0, 1.5, 0); candle.add(candleLight);
        }
        cakeGroup.rotation.x = 0.15; cakeGroup.visible = false; scene.add(cakeGroup);
    }

    function animateThree() {
        requestAnimationFrame(animateThree);
        const time = Date.now() * 0.001;
        if (particles) {
            particles.rotation.y += 0.002;
            particles.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
        }
        if (cakeGroup && cakeGroup.visible) {
            cakeGroup.rotation.y = Math.sin(time * 0.5) * 0.2; 
            const cakeScaleTarget = (targetScale > 1.8) ? 1 : 0.01;
            cakeGroup.scale.lerp(new THREE.Vector3(cakeScaleTarget, cakeScaleTarget, cakeScaleTarget), 0.1);
            cakeFlames.forEach((flame, index) => {
                const scaleY = 1 + Math.sin(time * 10 + index) * 0.2 + (Math.random() * 0.2);
                const scaleX = 1 + Math.cos(time * 10 + index) * 0.1;
                flame.scale.set(scaleX, scaleY, scaleX);
                flame.material.color.setHSL(0.08, 1, 0.5 + Math.random() * 0.2);
            });
        }
        renderer.render(scene, camera);
    }

    // ================= MEDIAPIPE & å¯è§†åŒ–é€»è¾‘ =================
    
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');
    
    const textBirthday = document.getElementById('text-birthday');
    const textName = document.getElementById('text-name');
    const statusText = document.getElementById('status-text');

    let lastPalmX = null;
    let lastTime = 0;
    let swipeCooldown = false;
    let switchTriggerEffect = 0; // ç”¨äºç»˜åˆ¶åˆ‡æ¢è§¦å‘æ—¶çš„ç‰¹æ•ˆ
    const TRIGGER_THRESHOLD = 2.2; 

    function switchScene(direction) {
        if (swipeCooldown) return;
        if (direction > 0) currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
        else currentShapeIndex = (currentShapeIndex - 1 + shapes.length) % shapes.length;

        console.log("åˆ‡æ¢åœºæ™¯:", shapes[currentShapeIndex]);
        createParticles(shapes[currentShapeIndex]);

        textBirthday.classList.remove('active');
        textName.classList.remove('active');
        if (cakeGroup) cakeGroup.visible = false;
        if (particles) particles.visible = true;

        // è§¦å‘è§†è§‰ç‰¹æ•ˆæ ‡è®° (Canvasç»˜å›¾ç”¨)
        switchTriggerEffect = 20; 

        swipeCooldown = true;
        statusText.innerText = "âœ¨ åˆ‡æ¢æˆåŠŸï¼å†·å´ä¸­...";
        setTimeout(() => { 
            swipeCooldown = false; 
            statusText.innerText = "âœ… å‡†å¤‡å°±ç»ª";
        }, 800);
    }

    window.addEventListener('keydown', (event) => {
        if (event.key === 'ArrowRight') switchScene(1);
        else if (event.key === 'ArrowLeft') switchScene(-1);
    });

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';
        
        // æ¸…ç©º Canvas
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        // 1. ç»˜åˆ¶æ‘„åƒå¤´ç”»é¢ (åŠé€æ˜ï¼Œå¢åŠ ç§‘æŠ€æ„Ÿ)
        canvasCtx.globalAlpha = 0.8;
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.globalAlpha = 1.0;

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // === ç»˜åˆ¶åŸºç¡€éª¨æ¶ ===
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, 
                          {color: '#00FF00', lineWidth: 2}); // ç»¿è‰²è¿çº¿
            drawLandmarks(canvasCtx, landmarks, 
                          {color: '#FFFFFF', lineWidth: 1, radius: 3}); // ç™½è‰²èŠ‚ç‚¹

            // === è·å–å…³é”®ç‚¹ ===
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const palmBase = landmarks[9]; // ä¸­æŒ‡æ ¹éƒ¨ï¼Œä½œä¸ºæŒ¥æ‰‹è¯†åˆ«ç‚¹
            
            // === 2. ç¼©æ”¾æ§åˆ¶ç‚¹å¯è§†åŒ– (é»„è‰²) ===
            // ç»˜åˆ¶æ‹‡æŒ‡å’Œé£ŸæŒ‡çš„è¿çº¿
            canvasCtx.beginPath();
            canvasCtx.moveTo(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height);
            canvasCtx.lineTo(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height);
            canvasCtx.strokeStyle = '#FFFF00';
            canvasCtx.lineWidth = 4;
            canvasCtx.stroke();

            // ç»˜åˆ¶æŒ‡å°–å¤§ç‚¹
            [thumbTip, indexTip].forEach(p => {
                canvasCtx.beginPath();
                canvasCtx.arc(p.x * canvasElement.width, p.y * canvasElement.height, 8, 0, 2 * Math.PI);
                canvasCtx.fillStyle = '#FFFF00';
                canvasCtx.fill();
            });

            // === 3. æŒ¥æ‰‹æ§åˆ¶ç‚¹å¯è§†åŒ– (çº¢è‰²) ===
            const palmX = palmBase.x;
            const palmY = palmBase.y;
            const px = palmX * canvasElement.width;
            const py = palmY * canvasElement.height;

            // å¦‚æœåˆšåˆšè§¦å‘äº†åˆ‡æ¢ï¼Œç”»ä¸€ä¸ªçˆ†ç‚¸åœˆ
            if (switchTriggerEffect > 0) {
                canvasCtx.beginPath();
                canvasCtx.arc(px, py, 50 - switchTriggerEffect, 0, 2 * Math.PI);
                canvasCtx.strokeStyle = `rgba(255, 255, 255, ${switchTriggerEffect / 20})`;
                canvasCtx.lineWidth = 5;
                canvasCtx.stroke();
                switchTriggerEffect--;
            }

            // ç»˜åˆ¶æ ¸å¿ƒè¯†åˆ«ç‚¹ (çº¢ç‚¹)
            canvasCtx.beginPath();
            canvasCtx.arc(px, py, 10, 0, 2 * Math.PI);
            canvasCtx.fillStyle = swipeCooldown ? '#555555' : '#FF0000'; // å†·å´æ—¶å˜ç°
            canvasCtx.fill();
            // å¤–åœˆå…‰æ™•
            canvasCtx.beginPath();
            canvasCtx.arc(px, py, 15, 0, 2 * Math.PI);
            canvasCtx.strokeStyle = swipeCooldown ? '#555555' : '#FF0000';
            canvasCtx.lineWidth = 2;
            canvasCtx.stroke();

            // === 4. é€»è¾‘å¤„ç† ===
            // è®¡ç®—è·ç¦»
            const distance = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
            let rawScale = distance * 10; 
            targetScale = Math.max(0.5, Math.min(3.5, rawScale));

            const isZoomedIn = targetScale > TRIGGER_THRESHOLD;
            // åœºæ™¯é€»è¾‘
            if (currentShapeIndex === 0) {
                isZoomedIn ? textBirthday.classList.add('active') : textBirthday.classList.remove('active');
            } else if (currentShapeIndex === 1) {
                if (isZoomedIn) { cakeGroup.visible = true; if(particles) particles.visible = false; }
                else { cakeGroup.visible = false; if(particles) particles.visible = true; }
            } else if (currentShapeIndex === 2) {
                isZoomedIn ? textName.classList.add('active') : textName.classList.remove('active');
            }

            // æŒ¥æ‰‹é€»è¾‘
            const currentTime = Date.now();
            if (lastPalmX !== null) {
                const deltaX = palmX - lastPalmX;
                const velocity = Math.abs(deltaX) / (currentTime - lastTime);
                
                // è°ƒè¯•æ–‡å­—ç»˜åˆ¶åœ¨æ‰‹ä¸Š
                // canvasCtx.fillStyle = "white";
                // canvasCtx.fillText(`Vel: ${velocity.toFixed(4)}`, px + 20, py);

                if (Math.abs(deltaX) > 0.1 && velocity > 0.0015) {
                    const direction = deltaX > 0 ? 1 : -1;
                    switchScene(direction);
                }
            }
            lastPalmX = palmX;
            lastTime = currentTime;

        } else {
            lastPalmX = null;
            statusText.innerText = "ğŸ‘€ è¯·å°†æ‰‹æ”¾å…¥ç”»é¢ä¸­...";
        }
        
        canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
    hands.onResults(onResults);

    const cameraMedia = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });

    initThree();
    cameraMedia.start();
</script>
</body>
</html>
