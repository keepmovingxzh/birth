<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>magic</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Microsoft YaHei', sans-serif; }
        
        /* å®¹å™¨æ ·å¼ */
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-container { position: absolute; bottom: 20px; right: 20px; z-index: 2; width: 320px; height: 240px; border-radius: 10px; overflow: hidden; border: 2px solid rgba(255,255,255,0.3); transform: scaleX(-1); opacity: 0.6; transition: opacity 0.3s; }
        #video-container:hover { opacity: 1; }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        /* æç¤ºå’ŒåŠ è½½æ–‡å­— */
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px; pointer-events: none; z-index: 10; }
        .instruction { position: absolute; top: 20px; left: 20px; color: rgba(255,255,255,0.6); z-index: 3; pointer-events: none; text-shadow: 0 0 5px #000; }
        
        /* ç‰¹æ•ˆæ–‡å­—å±‚ */
        .overlay-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 80px;
            font-weight: bold;
            color: transparent;
            background-image: linear-gradient(to right, #ff00cc, #3333ff, #00ccff); /* ç‚«å½©æ¸å˜ */
            -webkit-background-clip: text;
            background-clip: text;
            opacity: 0; /* é»˜è®¤éšè— */
            transition: opacity 0.8s ease-in-out, transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 5;
            pointer-events: none;
            text-align: center;
            white-space: nowrap;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }
        
        /* å½“æ–‡å­—æ¿€æ´»æ—¶çš„æ ·å¼ */
        .overlay-text.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
        }
    </style>
    
    <!-- å¼•å…¥ MediaPipe å’Œ Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨å‡†å¤‡ç”Ÿæ—¥æƒŠå–œ...<br>(è¯·å…è®¸æ‘„åƒå¤´æƒé™)</div>
    
    <div class="instruction">
        <h3>ğŸ® é­”æ³•æ‰‹åŠ¿æŒ‡å—ï¼š</h3>
        <p>ğŸ‘Œ <b>å¼ å¼€æ‰‹æŒ‡</b>ï¼šæ”¾å¤§æ˜Ÿäº‘å¹¶è§¦å‘æƒŠå–œ</p>
        <p>ğŸ¤ <b>æåˆæ‰‹æŒ‡</b>ï¼šç¼©å°éšè—æƒŠå–œ</p>
        <p>ğŸ‘‹ <b>å¿«é€ŸæŒ¥æ‰‹</b>ï¼šåˆ‡æ¢ä¸‹ä¸€ä¸ªåœºæ™¯</p>
    </div>

    <!-- ç‰¹æ•ˆæ–‡å­—å…ƒç´  -->
    <div id="text-birthday" class="overlay-text">ğŸ‚ ç”Ÿæ—¥å¿«ä¹ï¼ğŸ‰</div>
    <div id="text-name" class="overlay-text">âœ¨ è§£æ”¿æ·¼ âœ¨</div>

    <div id="video-container">
        <video class="input_video"></video>
    </div>
    <div id="canvas-container"></div>

<script>
    // ================= THREE.JS åœºæ™¯è®¾ç½® =================
    let scene, camera, renderer, particles, cakeGroup;
    let cakeFlames = []; // å­˜å‚¨ç«ç„°ç½‘æ ¼ï¼Œç”¨äºåŠ¨ç”»é—ªçƒ
    let currentShapeIndex = 0;
    const shapes = ['galaxy', 'cake_mode', 'sphere']; 
    let targetScale = 1.0; 
    
    function initThree() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x111111, 0.002); //ç¨å¾®æš—ä¸€ç‚¹çš„èƒŒæ™¯ï¼Œçªå‡ºè›‹ç³•

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 40;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        // å¼€å¯é˜´å½±æ”¯æŒï¼Œå¢åŠ ç«‹ä½“æ„Ÿ
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // === ç¯å…‰å‡çº§ ===
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // ç¯å¢ƒå…‰æŸ”å’Œä¸€ç‚¹
        scene.add(ambientLight);

        // ä¸»å…‰æºï¼ˆæ¨¡æ‹Ÿå½±æ£šç¯å…‰ï¼‰
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // ä¾§è¡¥å…‰ï¼ˆæš–è‰²ï¼‰
        const spotLight = new THREE.SpotLight(0xffaa00, 0.5);
        spotLight.position.set(-10, 10, 0);
        scene.add(spotLight);

        createParticles(shapes[0]);
        createCake(); 

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animateThree();
    }

    function createParticles(type) {
        if (particles) scene.remove(particles);
        if (type === 'cake_mode') {
            type = 'tunnel'; 
        }

        const geometry = new THREE.BufferGeometry();
        const count = 6000;
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);

        const color1 = new THREE.Color(0x00ffff);
        const color2 = new THREE.Color(0xff00ff);

        for (let i = 0; i < count; i++) {
            let x, y, z;
            if (type === 'galaxy') {
                const branchAngle = (i % 5) * ((2 * Math.PI) / 5);
                const radius = Math.random() * 35;
                const spinAngle = radius * 0.8; 
                x = Math.cos(branchAngle + spinAngle) * radius + (Math.random()-0.5)*2;
                y = (Math.random()-0.5) * 4; 
                z = Math.sin(branchAngle + spinAngle) * radius + (Math.random()-0.5)*2;
            } else if (type === 'tunnel') {
                const angle = Math.random() * Math.PI * 2;
                const radius = 15 + Math.random() * 15;
                const depth = (Math.random() - 0.5) * 120;
                x = Math.cos(angle) * radius;
                y = Math.sin(angle) * radius;
                z = depth;
            } else {
                const r = 25 * Math.cbrt(Math.random());
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            }
            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            const mixedColor = color1.clone().lerp(color2, Math.random());
            colors[i * 3] = mixedColor.r;
            colors[i * 3 + 1] = mixedColor.g;
            colors[i * 3 + 2] = mixedColor.b;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const material = new THREE.PointsMaterial({
            size: 0.4, vertexColors: true, blending: THREE.AdditiveBlending,
            depthWrite: false, transparent: true, opacity: 0.8
        });
        particles = new THREE.Points(geometry, material);
        scene.add(particles);
    }

    // === ğŸ‚ é«˜çº§è›‹ç³•åˆ¶ä½œå‡½æ•° ===
    function createCake() {
        cakeGroup = new THREE.Group();
        cakeFlames = []; // æ¸…ç©ºä¹‹å‰çš„ç«ç„°å¼•ç”¨

        // æè´¨å®šä¹‰
        const creamWhiteMat = new THREE.MeshStandardMaterial({ color: 0xfffff0, roughness: 0.3 }); // äº®ç™½å¥¶æ²¹
        const creamPinkMat = new THREE.MeshStandardMaterial({ color: 0xffc0cb, roughness: 0.3 });  // ç²‰è‰²å¥¶æ²¹
        const plateMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.1, metalness: 0.3 }); // é“¶ç›˜å­
        const cherryMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.1, metalness: 0.1 }); // äº®çº¢æ¨±æ¡ƒ
        const candleMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.2, metalness: 0.4 }); // é‡‘è‰²èœ¡çƒ›
        const flameMat = new THREE.MeshBasicMaterial({ color: 0xff6600 }); // ç«ç„°

        // 1. æ‰˜ç›˜
        const plateGeo = new THREE.CylinderGeometry(11, 10, 0.5, 64);
        const plate = new THREE.Mesh(plateGeo, plateMat);
        plate.position.y = -2;
        plate.receiveShadow = true;
        cakeGroup.add(plate);

        // 2. åº•å±‚è›‹ç³• (å¤§åœ†æŸ±)
        const baseGeo = new THREE.CylinderGeometry(9, 9, 4, 64);
        const baseLayer = new THREE.Mesh(baseGeo, creamWhiteMat);
        baseLayer.castShadow = true;
        cakeGroup.add(baseLayer);

        // 3. åº•å±‚è£…é¥°ï¼šåº•éƒ¨çš„ä¸€åœˆå¥¶æ²¹çƒ
        for(let i=0; i<16; i++) {
            const angle = (i / 16) * Math.PI * 2;
            const x = Math.cos(angle) * 8.5;
            const z = Math.sin(angle) * 8.5;
            const puff = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), creamPinkMat);
            puff.position.set(x, -1.8, z);
            cakeGroup.add(puff);
        }

        // 4. é¡¶å±‚è›‹ç³• (å°åœ†æŸ±)
        const topGeo = new THREE.CylinderGeometry(6.5, 6.5, 3.5, 64);
        const topLayer = new THREE.Mesh(topGeo, creamPinkMat);
        topLayer.position.y = 3.75; // å åŠ é«˜åº¦
        topLayer.castShadow = true;
        cakeGroup.add(topLayer);

        // 5. é¡¶å±‚è£…é¥°ï¼šè¿æ¥å¤„çš„å¥¶æ²¹èŠ±è¾¹ (Torus)
        const torusGeo = new THREE.TorusGeometry(6.3, 0.4, 16, 64);
        const ring = new THREE.Mesh(torusGeo, creamWhiteMat);
        ring.rotation.x = Math.PI / 2;
        ring.position.y = 2.0;
        cakeGroup.add(ring);

        // 6. é¡¶éƒ¨æ¨±æ¡ƒå’Œèœ¡çƒ›
        // æˆ‘ä»¬æ”¾ä¸€åœˆæ¨±æ¡ƒï¼Œä¸­é—´æ”¾ä¸€æ ¹å¤§èœ¡çƒ›ï¼Œæˆ–è€…ä¸€åœˆèœ¡çƒ›ã€‚è¿™é‡Œåšä¸€åœˆæ¨±æ¡ƒ+5æ ¹èœ¡çƒ›ã€‚
        
        // æ¨±æ¡ƒåœˆ
        for(let i=0; i<8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const x = Math.cos(angle) * 5.8;
            const z = Math.sin(angle) * 5.8;
            const cherry = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), cherryMat);
            cherry.position.set(x, 5.6, z);
            cakeGroup.add(cherry);
        }

        // èœ¡çƒ› (5æ ¹)
        for(let i=0; i<5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            const r = 3.5;
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            
            // çƒ›èº«
            const candleGeo = new THREE.CylinderGeometry(0.15, 0.15, 2.5, 16);
            const candle = new THREE.Mesh(candleGeo, candleMat);
            candle.position.set(x, 6.5, z);
            cakeGroup.add(candle);
            
            // ç«ç„°
            const flameGeo = new THREE.ConeGeometry(0.25, 0.8, 16);
            const flame = new THREE.Mesh(flameGeo, flameMat);
            flame.position.set(0, 1.6, 0); // ç›¸å¯¹èœ¡çƒ›çš„ä½ç½®
            candle.add(flame);
            
            // å°†ç«ç„°åŠ å…¥æ•°ç»„ä»¥ä¾¿åŠ¨ç”»æ§åˆ¶
            cakeFlames.push(flame);

            // æ¯ä¸ªèœ¡çƒ›å¢åŠ ä¸€ä¸ªå°ç‚¹å…‰æºï¼Œç…§äº®å‘¨å›´
            const candleLight = new THREE.PointLight(0xffaa00, 0.5, 5);
            candleLight.position.set(0, 1.5, 0);
            candle.add(candleLight);
        }

        // æ•´ä½“è°ƒæ•´
        cakeGroup.rotation.x = 0.15; // ç¨å¾®å‰å€¾è§†è§’
        cakeGroup.visible = false; 
        scene.add(cakeGroup);
    }

    function animateThree() {
        requestAnimationFrame(animateThree);
        
        const time = Date.now() * 0.001;

        // ç²’å­åŠ¨ç”»
        if (particles) {
            particles.rotation.y += 0.002;
            particles.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
        }

        // è›‹ç³•åŠ¨ç”»
        if (cakeGroup && cakeGroup.visible) {
            // ç¼“æ…¢æ—‹è½¬å±•ç¤º
            cakeGroup.rotation.y = Math.sin(time * 0.5) * 0.2; 

            // å¼¹å‡ºæ•ˆæœ
            const cakeScaleTarget = (targetScale > 1.8) ? 1 : 0.01;
            cakeGroup.scale.lerp(new THREE.Vector3(cakeScaleTarget, cakeScaleTarget, cakeScaleTarget), 0.1);

            // ğŸ”¥ ç«ç„°é—ªçƒç‰¹æ•ˆ
            cakeFlames.forEach((flame, index) => {
                // éšæœºç¼©æ”¾æ¨¡æ‹Ÿé—ªçƒ
                const scaleY = 1 + Math.sin(time * 10 + index) * 0.2 + (Math.random() * 0.2);
                const scaleX = 1 + Math.cos(time * 10 + index) * 0.1;
                flame.scale.set(scaleX, scaleY, scaleX);
                // å¾®å¾®æ”¹å˜é¢œè‰² brightness
                flame.material.color.setHSL(0.08, 1, 0.5 + Math.random() * 0.2);
            });
        }

        renderer.render(scene, camera);
    }

    // ================= MEDIAPIPE é€»è¾‘ (ä¿æŒä¸å˜) =================
    const videoElement = document.getElementsByClassName('input_video')[0];
    const textBirthday = document.getElementById('text-birthday');
    const textName = document.getElementById('text-name');

    let lastPalmX = null;
    let lastTime = 0;
    let swipeCooldown = false;
    const TRIGGER_THRESHOLD = 2.2; 

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const distance = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
            let rawScale = distance * 10; 
            targetScale = Math.max(0.5, Math.min(3.5, rawScale));

            const isZoomedIn = targetScale > TRIGGER_THRESHOLD;

            if (currentShapeIndex === 0) {
                if (isZoomedIn) textBirthday.classList.add('active');
                else textBirthday.classList.remove('active');
                if (cakeGroup) cakeGroup.visible = false;
                textName.classList.remove('active');
            } else if (currentShapeIndex === 1) {
                textBirthday.classList.remove('active');
                textName.classList.remove('active');
                if (isZoomedIn) {
                    cakeGroup.visible = true;
                    if(particles) particles.visible = false; 
                } else {
                    cakeGroup.visible = false;
                    if(particles) particles.visible = true;
                }
            } else if (currentShapeIndex === 2) {
                textBirthday.classList.remove('active');
                if (cakeGroup) cakeGroup.visible = false;
                if (isZoomedIn) textName.classList.add('active');
                else textName.classList.remove('active');
            }

            const palmX = landmarks[9].x;
            const currentTime = Date.now();
            if (lastPalmX !== null && !swipeCooldown) {
                const deltaX = palmX - lastPalmX;
                const velocity = Math.abs(deltaX) / (currentTime - lastTime);
                if (Math.abs(deltaX) > 0.1 && velocity > 0.0015) {
                    if (deltaX > 0) currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
                    else currentShapeIndex = (currentShapeIndex - 1 + shapes.length) % shapes.length;
                    
                    createParticles(shapes[currentShapeIndex]);
                    textBirthday.classList.remove('active');
                    textName.classList.remove('active');
                    if(cakeGroup) cakeGroup.visible = false;
                    if(particles) particles.visible = true;
                    swipeCooldown = true;
                    setTimeout(() => { swipeCooldown = false; }, 800);
                }
            }
            lastPalmX = palmX;
            lastTime = currentTime;
        } else {
            lastPalmX = null;
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
    hands.onResults(onResults);

    const cameraMedia = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });

    initThree();
    cameraMedia.start();
</script>
